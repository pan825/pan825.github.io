<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G Vector Visualization</title>
    <style>
        :root {
            --bg: #0f1115;
            --panel: #151822;
            --ink: #e6e6e6;
            --muted: #9aa4b2;
            --accent: #33d17a;
            --edge: #222633;
            --warning: #ff6b6b;
        }
        
        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            background: var(--bg);
            color: var(--ink);
            font-family: system-ui, Segoe UI, Roboto, Arial;
            overflow-x: hidden;
        }
        
        .header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--edge);
            background: var(--panel);
        }
        
        .container {
            display: grid;
            grid-template-columns: 350px 1fr;
            height: calc(100vh - 60px);
            gap: 0;
        }
        
        .controls {
            background: var(--panel);
            border-right: 1px solid var(--edge);
            padding: 20px;
            overflow-y: auto;
        }
        
        .canvas-container {
            position: relative;
            background: var(--bg);
        }
        
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(34, 38, 51, 0.5);
            border-radius: 8px;
            border: 1px solid var(--edge);
        }
        
        .section-title {
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--accent);
            font-size: 14px;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: var(--muted);
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 8px;
        }
        
        input[type="number"] {
            width: 100%;
            padding: 6px 8px;
            background: #0e1016;
            border: 1px solid #2a2e3d;
            border-radius: 4px;
            color: var(--ink);
            font-size: 12px;
        }
        
        .vector-display {
            font-family: 'Courier New', monospace;
            background: #0e1016;
            border: 1px solid #2a2e3d;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-size: 12px;
        }
        
        .vector-component {
            margin: 3px 0;
        }
        
        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 6px;
            margin-top: 10px;
        }
        
        button {
            background: #0e1016;
            border: 1px solid #2a2e3d;
            color: var(--ink);
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 11px;
            cursor: pointer;
            transition: border-color 0.2s;
        }
        
        button:hover {
            border-color: var(--accent);
        }
        
        .custom-vector {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }
        
        .legend-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid var(--edge);
            flex-shrink: 0;
        }
        
        .info-panel {
            background: rgba(51, 209, 122, 0.1);
            border: 1px solid var(--accent);
            border-radius: 6px;
            padding: 12px;
            font-size: 12px;
            line-height: 1.4;
        }
        
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
            .controls {
                border-right: none;
                border-bottom: 1px solid var(--edge);
                max-height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 style="margin: 0; font-size: 18px;">G Vector 3D Visualization</h1>
        <p style="margin: 5px 0 0 0; font-size: 13px; color: var(--muted);">
            Interactive visualization of gravity vectors from tilt angles and custom vectors
        </p>
    </div>
    
    <div class="container">
        <div class="controls">
            <!-- Tilt-based G Vector -->
            <div class="section">
                <div class="section-title">Tilt-based G Vector</div>
                <div class="input-group">
                    <label>α (Alpha) - Tilt angle: 0° (upright) → 180° (upside down)</label>
                    <input type="range" id="alphaRange" min="0" max="180" value="0" step="1">
                    <input type="number" id="alphaNumber" min="0" max="180" value="0" step="1">
                </div>
                <div class="input-group">
                    <label>γ (Gamma) - Tilt orientation: 0°=ND, 180°=NU, 90°=LED, -90°=RED</label>
                    <input type="range" id="gammaRange" min="-180" max="180" value="0" step="1">
                    <input type="number" id="gammaNumber" min="-180" max="180" value="0" step="1">
                </div>
                <div class="vector-display" id="tiltVectorDisplay">
                    <div>G = (sin α·cos γ, sin α·sin γ, -cos α)</div>
                    <div class="vector-component">Gx = <span id="gx">0.00</span></div>
                    <div class="vector-component">Gy = <span id="gy">-1.00</span></div>
                    <div class="vector-component">Gz = <span id="gz">0.00</span></div>
                    <div class="vector-component">||G|| = <span id="gnorm">1.00</span></div>
                    <div style="border-top: 1px solid #2a2e3d; margin-top: 8px; padding-top: 8px;">
                        <div class="vector-component"><strong>Azimuth Calculations:</strong></div>
                        <div class="vector-component">YO (Yaw-Only) = <span id="yo">0.00</span>°</div>
                        <div class="vector-component">EH (Earth-Horizontal) = <span id="eh">0.00</span>°</div>
                        <div class="vector-component">TA (Tilted) = <span id="ta">0.00</span>°</div>
                    </div>
                </div>
                <div class="preset-buttons">
                    <button onclick="setPreset('upright')">UP (Upright)</button>
                    <button onclick="setPreset('upsidedown')">UD (Upside-Down)</button>
                    <button onclick="setPreset('nosedown')">ND (Nose-Down)</button>
                    <button onclick="setPreset('noseup')">NU (Nose-Up)</button>
                    <button onclick="setPreset('lefteardown')">LED (Left-Ear-Down)</button>
                    <button onclick="setPreset('righteardown')">RED (Right-Ear-Down)</button>
                    <button onclick="setPreset('diagonal1')">Diagonal ND+LED</button>
                    <button onclick="setPreset('diagonal2')">Diagonal NU+RED</button>
                    <button onclick="setPreset('sleeping')">Sleeping</button>
                    <button onclick="setPreset('climbing')">Climbing</button>
                    <button onclick="setPreset('hanging')">Hanging</button>
                    <button onclick="setPreset('custom')">Custom</button>
                </div>
            </div>
            
            <!-- Custom G Vector -->
            <div class="section">
                <div class="section-title">Custom G Vector</div>
                <div class="input-group">
                    <label>Enter custom vector components:</label>
                    <div class="custom-vector">
                        <input type="number" id="customX" placeholder="X" value="1" step="0.1">
                        <input type="number" id="customY" placeholder="Y" value="1" step="0.1">
                        <input type="number" id="customZ" placeholder="Z" value="0" step="0.1">
                    </div>
                    <button onclick="applyCustomVector()" style="width: 100%; margin-top: 8px;">Apply Custom Vector</button>
                </div>
                <div class="vector-display" id="customVectorDisplay">
                    <div>Custom G = (x, y, z)</div>
                    <div class="vector-component">Gx = <span id="customGx">1.00</span></div>
                    <div class="vector-component">Gy = <span id="customGy">1.00</span></div>
                    <div class="vector-component">Gz = <span id="customGz">0.00</span></div>
                    <div class="vector-component">||G|| = <span id="customGnorm">1.41</span></div>
                </div>
            </div>
            
            <!-- Visualization Controls -->
            <div class="section">
                <div class="section-title">Visualization Controls</div>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="showAxes" checked> Show coordinate axes
                    </label>
                </div>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="showGrid" checked> Show grid
                    </label>
                </div>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="showCustomVector"> Show custom vector
                    </label>
                </div>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="showOrientationVector" checked> Show orientation vector (α,γ)
                    </label>
                </div>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="showGVector" checked> Show G vector
                    </label>
                </div>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="showDrosophila" checked> Show drosophila model
                    </label>
                </div>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="showSphere" checked> Show reference sphere
                    </label>
                </div>
                <div class="input-group">
                    <label>Vector scale factor:</label>
                    <input type="range" id="scaleRange" min="0.5" max="3" value="1.5" step="0.1">
                    <input type="number" id="scaleNumber" min="0.5" max="3" value="1.5" step="0.1">
                </div>
            </div>
            
            <!-- Legend -->
            <div class="section">
                <div class="section-title">Legend</div>
                <div class="legend-items">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff4444;"></div>
                        <span>X-axis (Right)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #44ff44;"></div>
                        <span>Y-axis (Up)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #4444ff;"></div>
                        <span>Z-axis (Forward)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff9500;"></div>
                        <span>Custom G Vector</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #00ffff;"></div>
                        <span>Orientation Vector (α,γ)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff00ff;"></div>
                        <span>G Vector (Gravity)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #232a3a;"></div>
                        <span>Grid Lines</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #8B4513;"></div>
                        <span>Drosophila Model</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: rgba(255,255,255,0.1);"></div>
                        <span>Reference Sphere</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ffff00;"></div>
                        <span>G Vector on Sphere (α,γ)</span>
                    </div>
                </div>
            </div>
            
            <!-- Mathematical Theory Section -->
            <div class="section">
                <div class="section-title">
                    <span onclick="toggleMathSection()" style="cursor: pointer; user-select: none;">
                        📐 Mathematical Theory <span id="mathToggle">▼</span>
                    </span>
                </div>
                <div id="mathSection" style="display: none;">
                    <div style="font-size: 11px; line-height: 1.4; color: var(--muted);">
                        <h4 style="color: var(--accent); margin: 10px 0 5px 0;">Tilt Model Parameters</h4>
                        <p><strong>α (Alpha) - Tilt Angle:</strong><br>
                        Range: 0° to 180°<br>
                        • 0° = upright position (UP)<br>
                        • 180° = upside-down position (UD)<br>
                        Formula: α = acos(-G<sub>Z</sub>)</p>
                        
                        <p><strong>γ (Gamma) - Tilt Orientation:</strong><br>
                        Range: -180° to +180°<br>
                        • 0° = nose-down position (ND)<br>
                        • 180° = nose-up position (NU)<br>
                        • 90° = left-ear-down position (LED) - ready for left roll<br>
                        • -90° = right-ear-down position (RED) - ready for right roll<br>
                        Formula: γ = atan2(G<sub>Y</sub>, G<sub>X</sub>)<br>
                        <em>Note: γ=±90° positions for roll; α executes the rolling motion</em></p>
                        
                        <h4 style="color: var(--accent); margin: 15px 0 5px 0;">Spherical ↔ Cartesian Transformations</h4>
                        <p><strong>Forward Transformation (α, γ → GX, GY, GZ):</strong></p>
                        <div style="background: #0a0c10; padding: 8px; border-radius: 4px; font-family: monospace;">
                            GX = sin(α) · cos(γ)<br>
                            GY = sin(α) · sin(γ)<br>
                            GZ = -cos(α)
                        </div>
                        
                        <p><strong>Inverse Transformation (GX, GY, GZ → α, γ):</strong></p>
                        <div style="background: #0a0c10; padding: 8px; border-radius: 4px; font-family: monospace;">
                            α = acos(-GZ)<br>
                            γ = atan2(GY, GX)
                        </div>
                        
                        <h4 style="color: var(--accent); margin: 15px 0 5px 0;">3D Azimuth Tuning Curves</h4>
                        <p>Three different methods for computing azimuth in 3D space:</p>
                        
                        <p><strong>1. Yaw-Only (YO) Azimuth:</strong><br>
                        Projects gravity vector onto horizontal plane, ignoring tilt:</p>
                        <div style="background: #0a0c10; padding: 8px; border-radius: 4px; font-family: monospace;">
                            YO = atan2(sin(α)·sin(γ), sin(α)·cos(γ))
                        </div>
                        
                        <p><strong>2. Earth-Horizontal (EH) Azimuth:</strong><br>
                        Azimuth relative to earth's horizontal plane:</p>
                        <div style="background: #0a0c10; padding: 8px; border-radius: 4px; font-family: monospace;">
                            EH = atan2(Gx/||Gh||, Gz/||Gh||)<br>
                            where ||Gh|| = √(Gx² + Gz²)
                        </div>
                        
                        <p><strong>3. Tilted (TA) Azimuth:</strong><br>
                        Azimuth in the tilted reference frame:</p>
                        <div style="background: #0a0c10; padding: 8px; border-radius: 4px; font-family: monospace;">
                            TA = EHAz - γ - atan2(-sin(γ), cos(α)·cos(γ))
                        </div>
                        <p style="font-size: 11px; margin-top: 5px;">Where EHAz = 0° (fixed reference angle).</p>
                        
                        <h4 style="color: var(--accent); margin: 15px 0 5px 0;">Vector Definitions</h4>
                        <p><strong>Orientation Vector (Cyan):</strong> Head/body "up" direction</p>
                        <div style="background: #0a0c10; padding: 8px; border-radius: 4px; font-family: monospace;">
                            Orientation = [-sin(α)cos(γ), -sin(α)sin(γ), cos(α)]
                        </div>
                        
                        <p><strong>G Vector (Magenta):</strong> Gravity direction in head frame</p>
                        <div style="background: #0a0c10; padding: 8px; border-radius: 4px; font-family: monospace;">
                            G = [sin(α)cos(γ), sin(α)sin(γ), -cos(α)]
                        </div>
                        <p style="font-size: 11px; margin-top: 5px;">
                        • Orientation vector: Where head "up" points in space<br>
                        • G vector: Direction of gravity as perceived by head<br>
                        • These vectors are opposite to each other (G = -Orientation)</p>
                        
                        <h4 style="color: var(--accent); margin: 15px 0 5px 0;">Coordinate System</h4>
                        <p>Head-centered reference frame (paper convention):<br>
                        • +X axis: Right ear direction<br>
                        • +Y axis: Nose direction<br>
                        • +Z axis: Up direction (gravity = [0,0,-1] when upright)</p>
                        
                        <h4 style="color: var(--accent); margin: 15px 0 5px 0;">Spherical Coordinate Mapping</h4>
                        <p><strong>Longitude/Latitude Analogy (Y-axis as polar axis):</strong><br>
                        • γ (gamma) = Longitude: Rotation around the nose axis (Y-axis)<br>
                        • α (alpha) = Latitude: Angle from nose+ pole to nose- pole<br>
                        • Pole positions: α=0° (nose+), α=180° (nose-)<br>
                        • Equator: α=90° (all horizontal orientations)</p>
                        
                        <h4 style="color: var(--accent); margin: 15px 0 5px 0;">2D Map Projection</h4>
                        <p>Plate Carrée projection for 2D visualization:</p>
                        <div style="background: #0a0c10; padding: 8px; border-radius: 4px; font-family: monospace;">
                            x = (γ + 180°) / 360° · W  (longitude)<br>
                            y = α / 180° · H           (latitude)
                        </div>
                        
                        <h4 style="color: var(--accent); margin: 15px 0 5px 0;">Roll Mechanics</h4>
                        <p><strong>Two-Step Roll Process:</strong><br>
                        1. <strong>γ (Positioning):</strong> Sets the orientation axis<br>
                        • γ=±90° positions the body for rolling motion<br>
                        • γ=0°/180° positions for pitching motion<br><br>
                        2. <strong>α (Execution):</strong> Executes the movement<br>
                        • When γ=±90°, changing α creates rolling motion<br>
                        • When γ=0°/180°, changing α creates pitching motion</p>
                        
                        <h4 style="color: var(--accent); margin: 15px 0 5px 0;">Azimuth Frame Differences</h4>
                        <p><strong>YO (Yaw-Only):</strong> Simplest method, treats device as if always level. Good for basic heading calculations but ignores device orientation.<br><br>
                        <strong>EH (Earth-Horizontal):</strong> Accounts for device tilt by projecting onto earth's horizontal plane. Most intuitive for navigation applications.<br><br>
                        <strong>TA (Tilted):</strong> Calculates azimuth in the device's own tilted reference frame. Useful for studying how neurons encode 3D orientation.</p>
                        
                        <h4 style="color: var(--accent); margin: 15px 0 5px 0;">Applications</h4>
                        <p>• 3D compass neurons in animal navigation<br>
                        • Head direction cells in neuroscience research<br>
                        • Virtual/Augmented Reality head tracking<br>
                        • Inertial Navigation Systems<br>
                        • Robotic orientation and balance</p>
                        
                        <h4 style="color: var(--accent); margin: 15px 0 5px 0;">References</h4>
                        <p style="font-size: 10px;">
                        • Angelaki, D. E., & Laurens, J. (2020). A gravity-based three-dimensional compass in the mouse brain. Nature Communications.<br>
                        • Page, H., et al. (2017). A detailed model for gravity-based 3D orientation in vertebrates. Journal of Neurophysiology.
                        </p>
                    </div>
                </div>
            </div>
            
            <!-- Info Panel -->
            <div class="info-panel">
                <strong>Quick Reference:</strong><br>
                The gravity vector G represents the "downward" direction in the head coordinate system. Use the presets to explore different orientations, or adjust α and γ manually to see how they map to 3D space.
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js setup
        let scene, camera, renderer, controls;
        let customVector, orientationVector, gVector;
        let coordinateAxes = { x: null, y: null, z: null };
        let gridHelper;
        let drosophilaModel;
        let referenceSphere;
        let sphereGridLines;
        let currentPositionMarker;
        
        // Current vector values
        let currentAlpha = 0;
        let currentGamma = 0;
        let currentCustomVector = { x: 1, y: 1, z: 0 };
        let vectorScale = 1.5;
        
        // Fixed EHAz value for TA calculation (no slider)
        const EHAz = 0;
        
        function init() {
            const canvas = document.getElementById('canvas');
            const container = canvas.parentElement;
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f1115);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            
            // Controls (basic rotation)
            setupControls();
            
            // Create coordinate axes
            createCoordinateAxes();
            
            // Create grid
            createGrid();
            
            // Create vectors
            createVectors();
            
            // Create drosophila model
            createDrosophilaModel();
            
            // Create reference sphere
            createReferenceSphere();
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // Initial render
            updateCalculations();
            updateCustomVector();
            animate();
            
            // Event listeners
            setupEventListeners();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }
        
        function setupControls() {
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let targetRotationX = 0, targetRotationY = 0;
            let rotationX = 0, rotationY = 0;
            
            const canvas = document.getElementById('canvas');
            
            canvas.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            canvas.addEventListener('mousemove', (event) => {
                if (isMouseDown) {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
                    
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            canvas.addEventListener('wheel', (event) => {
                event.preventDefault();
                const zoom = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(zoom);
                camera.position.clampLength(2, 50);
            });
            
            // Smooth rotation animation
            function updateCameraRotation() {
                rotationX += (targetRotationX - rotationX) * 0.1;
                rotationY += (targetRotationY - rotationY) * 0.1;
                
                const radius = camera.position.length();
                camera.position.x = radius * Math.sin(rotationY) * Math.cos(rotationX);
                camera.position.y = radius * Math.sin(rotationX);
                camera.position.z = radius * Math.cos(rotationY) * Math.cos(rotationX);
                camera.lookAt(0, 0, 0);
                
                requestAnimationFrame(updateCameraRotation);
            }
            updateCameraRotation();
        }
        
        function createCoordinateAxes() {
            const axisLength = 2;
            const axisWidth = 0.05;
            
            // X-axis (red)
            const xGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
            const xMaterial = new THREE.MeshPhongMaterial({ color: 0xff4444 });
            coordinateAxes.x = new THREE.Mesh(xGeometry, xMaterial);
            coordinateAxes.x.rotation.z = -Math.PI / 2;
            coordinateAxes.x.position.x = axisLength / 2;
            scene.add(coordinateAxes.x);
            
            // Y-axis (green)
            const yGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
            const yMaterial = new THREE.MeshPhongMaterial({ color: 0x44ff44 });
            coordinateAxes.y = new THREE.Mesh(yGeometry, yMaterial);
            coordinateAxes.y.position.y = axisLength / 2;
            scene.add(coordinateAxes.y);
            
            // Z-axis (blue)
            const zGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
            const zMaterial = new THREE.MeshPhongMaterial({ color: 0x4444ff });
            coordinateAxes.z = new THREE.Mesh(zGeometry, zMaterial);
            coordinateAxes.z.rotation.x = Math.PI / 2;
            coordinateAxes.z.position.z = axisLength / 2;
            scene.add(coordinateAxes.z);
            
            // Add axis labels (simple spheres at the ends)
            const labelGeometry = new THREE.SphereGeometry(0.1, 8, 6);
            
            const xLabel = new THREE.Mesh(labelGeometry, new THREE.MeshPhongMaterial({ color: 0xff4444 }));
            xLabel.position.set(axisLength, 0, 0);
            scene.add(xLabel);
            
            const yLabel = new THREE.Mesh(labelGeometry, new THREE.MeshPhongMaterial({ color: 0x44ff44 }));
            yLabel.position.set(0, axisLength, 0);
            scene.add(yLabel);
            
            const zLabel = new THREE.Mesh(labelGeometry, new THREE.MeshPhongMaterial({ color: 0x4444ff }));
            zLabel.position.set(0, 0, axisLength);
            scene.add(zLabel);
        }
        
        function createGrid() {
            gridHelper = new THREE.GridHelper(4, 20, 0x232a3a, 0x232a3a);
            scene.add(gridHelper);
        }
        
        function createVectors() {
            // Custom vector (orange)
            customVector = createArrow(0xff9500, 'Custom Vector');
            customVector.visible = false; // Start hidden by default
            scene.add(customVector);
            
            // Orientation vector (cyan) - shows current α,γ orientation
            orientationVector = createArrow(0x00ffff, 'Orientation Vector');
            scene.add(orientationVector);
            
            // G vector (magenta) - shows gravity direction
            gVector = createArrow(0xff00ff, 'G Vector');
            scene.add(gVector);
        }
        
        function createReferenceSphere() {
            const sphereRadius = 1.2;
            
            // Create the main sphere
            const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 32, 16);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            referenceSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(referenceSphere);
            
            // Create sphere grid lines (latitude and longitude)
            sphereGridLines = new THREE.Group();
            
            // Latitude lines (constant α - circles around the Y-axis as polar axis)
            const latLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x666666, 
                transparent: true, 
                opacity: 0.6 
            });
            
            for (let alpha = 30; alpha <= 150; alpha += 30) {
                const points = [];
                const alphaRad = alpha * Math.PI / 180;
                
                for (let gamma = 0; gamma <= 360; gamma += 5) {
                    const gammaRad = gamma * Math.PI / 180;
                    
                    // Paper coordinates: GX = sin(α)cos(γ), GY = sin(α)sin(γ), GZ = -cos(α)
                    const gx = Math.sin(alphaRad) * Math.cos(gammaRad);
                    const gy = Math.sin(alphaRad) * Math.sin(gammaRad);
                    const gz = -Math.cos(alphaRad);
                    
                    // Map to Three.js: Paper Y (nose) → Three.js Z, Paper Z (up) → Three.js Y
                    const x = gx * sphereRadius;      // Right ear → X
                    const y = gz * sphereRadius;      // Up → Y (Three.js up)
                    const z = gy * sphereRadius;      // Nose → Z (Three.js forward)
                    
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                const latGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const latLine = new THREE.Line(latGeometry, latLineMaterial);
                sphereGridLines.add(latLine);
            }
            
            // Longitude lines (constant γ - meridians from nose+ to nose- pole)
            const lonLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x888888, 
                transparent: true, 
                opacity: 0.6 
            });
            
            for (let gamma = 0; gamma < 360; gamma += 30) {
                const points = [];
                const gammaRad = gamma * Math.PI / 180;
                
                for (let alpha = 0; alpha <= 180; alpha += 5) {
                    const alphaRad = alpha * Math.PI / 180;
                    
                    // Paper coordinates: GX = sin(α)cos(γ), GY = sin(α)sin(γ), GZ = -cos(α)
                    const gx = Math.sin(alphaRad) * Math.cos(gammaRad);
                    const gy = Math.sin(alphaRad) * Math.sin(gammaRad);
                    const gz = -Math.cos(alphaRad);
                    
                    // Map to Three.js: Paper Y (nose) → Three.js Z, Paper Z (up) → Three.js Y
                    const x = gx * sphereRadius;      // Right ear → X
                    const y = gz * sphereRadius;      // Up → Y (Three.js up)
                    const z = gy * sphereRadius;      // Nose → Z (Three.js forward)
                    
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                const lonGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const lonLine = new THREE.Line(lonGeometry, lonLineMaterial);
                sphereGridLines.add(lonLine);
            }
            
            scene.add(sphereGridLines);
            
            // Create current position marker
            const markerGeometry = new THREE.SphereGeometry(0.05, 8, 6);
            const markerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffff00,
                emissive: 0x444400
            });
            currentPositionMarker = new THREE.Mesh(markerGeometry, markerMaterial);
            scene.add(currentPositionMarker);
            
            // Add equator line (α = 90°) - all horizontal orientations
            const equatorPoints = [];
            for (let gamma = 0; gamma <= 360; gamma += 5) {
                const gammaRad = gamma * Math.PI / 180;
                
                // At α = 90°: GX = cos(γ), GY = sin(γ), GZ = 0
                const gx = Math.cos(gammaRad);
                const gy = Math.sin(gammaRad);
                const gz = 0;  // -cos(90°) = 0
                
                // Map to Three.js coordinates
                const x = gx * sphereRadius;      // Right ear → X
                const y = gz * sphereRadius;      // Up → Y (0 for equator)
                const z = gy * sphereRadius;      // Nose → Z
                
                equatorPoints.push(new THREE.Vector3(x, y, z));
            }
            
            const equatorGeometry = new THREE.BufferGeometry().setFromPoints(equatorPoints);
            const equatorMaterial = new THREE.LineBasicMaterial({ 
                color: 0xaaaaaa, 
                transparent: true, 
                opacity: 0.8,
                linewidth: 2
            });
            const equatorLine = new THREE.Line(equatorGeometry, equatorMaterial);
            sphereGridLines.add(equatorLine);
            
            // Add prime meridian (γ = 0°) - nose-down meridian from nose+ to nose-
            const meridianPoints = [];
            for (let alpha = 0; alpha <= 180; alpha += 5) {
                const alphaRad = alpha * Math.PI / 180;
                
                // At γ = 0°: GX = sin(α), GY = 0, GZ = -cos(α)
                const gx = Math.sin(alphaRad);
                const gy = 0;  // sin(0°) = 0
                const gz = -Math.cos(alphaRad);
                
                // Map to Three.js coordinates
                const x = gx * sphereRadius;      // Right ear → X
                const y = gz * sphereRadius;      // Up → Y
                const z = gy * sphereRadius;      // Nose → Z (0 for γ=0°)
                
                meridianPoints.push(new THREE.Vector3(x, y, z));
            }
            
            const meridianGeometry = new THREE.BufferGeometry().setFromPoints(meridianPoints);
            const meridianMaterial = new THREE.LineBasicMaterial({ 
                color: 0xaaaaaa, 
                transparent: true, 
                opacity: 0.8,
                linewidth: 2
            });
            const meridianLine = new THREE.Line(meridianGeometry, meridianMaterial);
            sphereGridLines.add(meridianLine);
        }
        
        
        function updateSpherePosition() {
            if (!currentPositionMarker) return;
            
            // Get the tilt vector direction (paper coordinates)
            const paperVector = calculateTiltVector(currentAlpha, currentGamma);
            const sphereRadius = 1.2;
            
            // Transform to the same display coordinates as the tilt vector
            // Paper: X=right, Y=nose, Z=up  →  Three.js: X=right, Y=up, Z=forward
            const displayVector = new THREE.Vector3(
                paperVector.x,  // Right ear → X (same)
                paperVector.z,  // Up → Y (Three.js up)
                paperVector.y   // Nose → Z (Three.js forward)
            );
            
            // Scale to sphere radius to show intersection point
            const x = displayVector.x * sphereRadius;
            const y = displayVector.y * sphereRadius;
            const z = displayVector.z * sphereRadius;
            
            currentPositionMarker.position.set(x, y, z);
        }
        
        function createDrosophilaModel() {
            drosophilaModel = new THREE.Group();
            drosophilaModel.name = 'Drosophila';
            
            // Create realistic Drosophila with proper proportions and textures
            
            // THORAX (main body segment) - realistic segmented appearance
            const thoraxGeometry = new THREE.SphereGeometry(0.08, 16, 12);
            const thoraxMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x654321,
                shininess: 60,
                specular: 0x111111
            });
            const thorax = new THREE.Mesh(thoraxGeometry, thoraxMaterial);
            thorax.scale.set(1.2, 0.8, 1.8); // Barrel-shaped thorax
            thorax.position.set(0, 0, 0);
            drosophilaModel.add(thorax);
            
            // ABDOMEN - segmented, tapered
            const abdomenSegments = 6;
            for (let i = 0; i < abdomenSegments; i++) {
                const segmentSize = 0.06 - (i * 0.008); // Tapering
                const segmentGeometry = new THREE.SphereGeometry(segmentSize, 12, 8);
                const segmentMaterial = new THREE.MeshPhongMaterial({ 
                    color: i % 2 === 0 ? 0x8B4513 : 0x654321, // Alternating stripes
                    shininess: 40
                });
                const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                segment.scale.set(1, 0.7, 0.8);
                segment.position.set(0, -0.01, -0.15 - (i * 0.08));
                drosophilaModel.add(segment);
            }
            
            // HEAD - more realistic proportions
            const headGeometry = new THREE.SphereGeometry(0.055, 16, 12);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4A3F35,
                shininess: 30
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.scale.set(1.1, 0.9, 0.8);
            head.position.set(0, 0.02, 0.18);
            drosophilaModel.add(head);
            
            // COMPOUND EYES - large, characteristic of Drosophila
            const eyeGeometry = new THREE.SphereGeometry(0.035, 16, 12);
            const eyeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B0000, // Dark red compound eyes
                shininess: 100,
                specular: 0x442222
            });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.042, 0.015, 0.22);
            leftEye.scale.set(0.9, 1.1, 1);
            drosophilaModel.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.042, 0.015, 0.22);
            rightEye.scale.set(0.9, 1.1, 1);
            drosophilaModel.add(rightEye);
            
             // WINGS - Drosophila has only TWO wings (Diptera order)
             function createDrosophilaWing(isLeft) {
                 const wingGroup = new THREE.Group();
                 
                 // Create simple, natural Drosophila wing shape
                 const wingShape = new THREE.Shape();
                 
                 // Simplified but realistic wing outline
                 wingShape.moveTo(0, 0); // Wing base
                 wingShape.lineTo(0.3, 0.08); // Leading edge
                 wingShape.quadraticCurveTo(0.35, 0.06, 0.38, 0.02); // Wing tip
                 wingShape.quadraticCurveTo(0.36, -0.02, 0.3, -0.04); // Trailing edge start
                 wingShape.lineTo(0.15, -0.06); // Trailing edge middle
                 wingShape.quadraticCurveTo(0.08, -0.04, 0.02, -0.02); // Back to base
                 wingShape.lineTo(0, 0); // Close shape
                 
                 const wingGeometry = new THREE.ShapeGeometry(wingShape);
                 
                 // Clean wing material
                 const wingMaterial = new THREE.MeshPhongMaterial({ 
                     color: 0xF5F5F5,
                     transparent: true,
                     opacity: 0.6,
                     shininess: 200,
                     side: THREE.DoubleSide,
                     depthWrite: false
                 });
                 
                 const wing = new THREE.Mesh(wingGeometry, wingMaterial);
                 wingGroup.add(wing);
                 
                 // Simple but visible wing veins
                 const veins = new THREE.Group();
                 const veinMaterial = new THREE.LineBasicMaterial({ 
                     color: 0x666666, 
                     transparent: true, 
                     opacity: 0.8,
                     linewidth: 1
                 });
                 
                 // Main longitudinal veins (simple lines)
                 const vein1Points = [
                     new THREE.Vector3(0.02, 0.01, 0.001),
                     new THREE.Vector3(0.32, 0.05, 0.001)
                 ];
                 const vein1 = new THREE.Line(new THREE.BufferGeometry().setFromPoints(vein1Points), veinMaterial);
                 veins.add(vein1);
                 
                 const vein2Points = [
                     new THREE.Vector3(0.03, 0, 0.001),
                     new THREE.Vector3(0.30, 0.01, 0.001)
                 ];
                 const vein2 = new THREE.Line(new THREE.BufferGeometry().setFromPoints(vein2Points), veinMaterial);
                 veins.add(vein2);
                 
                 const vein3Points = [
                     new THREE.Vector3(0.04, -0.01, 0.001),
                     new THREE.Vector3(0.25, -0.03, 0.001)
                 ];
                 const vein3 = new THREE.Line(new THREE.BufferGeometry().setFromPoints(vein3Points), veinMaterial);
                 veins.add(vein3);
                 
                 // Cross veins
                 const crossVein1Points = [
                     new THREE.Vector3(0.15, 0.04, 0.001),
                     new THREE.Vector3(0.17, -0.01, 0.001)
                 ];
                 const crossVein1 = new THREE.Line(new THREE.BufferGeometry().setFromPoints(crossVein1Points), veinMaterial);
                 veins.add(crossVein1);
                 
                 wingGroup.add(veins);
                 
                 // Position and orient the wing naturally
                 if (isLeft) {
                     // Left wing
                     wingGroup.position.set(-0.07, 0.03, 0.04);
                     wingGroup.rotation.x = Math.PI / 12; // Slight upward angle
                     wingGroup.rotation.z = Math.PI / 8; // Outward angle
                     wingGroup.rotation.y = -Math.PI / 16; // Slight backward sweep
                 } else {
                     // Right wing - create symmetry by mirroring position and rotation
                     wingGroup.position.set(0.07, 0.03, 0.04);
                     wingGroup.rotation.x = Math.PI / 12; // Same upward angle
                     wingGroup.rotation.z = -Math.PI / 8; // Mirror outward angle
                     wingGroup.rotation.y = Math.PI / 16; // Mirror backward sweep
                     wingGroup.scale.x = -1; // Mirror the wing shape
                 }
                 
                 return wingGroup;
             }
             
             // Add halteres (small knob-like structures that replace hind wings in Diptera)
             function createHaltere(isLeft) {
                 const haltereGroup = new THREE.Group();
                 
                 // Haltere stalk
                 const stalkGeometry = new THREE.CylinderGeometry(0.001, 0.001, 0.015, 4);
                 const stalkmaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });
                 const stalk = new THREE.Mesh(stalkGeometry, stalkmaterial);
                 stalk.rotation.x = Math.PI / 4;
                 haltereGroup.add(stalk);
                 
                 // Haltere knob
                 const knobGeometry = new THREE.SphereGeometry(0.003, 6, 4);
                 const knobMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
                 const knob = new THREE.Mesh(knobGeometry, knobMaterial);
                 knob.position.set(0, 0.008, 0.008);
                 haltereGroup.add(knob);
                 
                 // Position halteres behind wings
                 const xPos = isLeft ? -0.05 : 0.05;
                 haltereGroup.position.set(xPos, 0.02, -0.02);
                 haltereGroup.rotation.z = isLeft ? Math.PI / 6 : -Math.PI / 6;
                 
                 return haltereGroup;
             }
             
             // Add only TWO wings (characteristic of Diptera)
             drosophilaModel.add(createDrosophilaWing(true));   // Left wing
             drosophilaModel.add(createDrosophilaWing(false));  // Right wing
             
             // Add halteres (modified hind wings)
             drosophilaModel.add(createHaltere(true));   // Left haltere
             drosophilaModel.add(createHaltere(false));  // Right haltere
            
            // LEGS - more realistic with joints
            function createLeg(side, position, angle) {
                const legGroup = new THREE.Group();
                
                // Coxa (hip joint)
                const coxaGeometry = new THREE.SphereGeometry(0.008, 6, 4);
                const legMaterial = new THREE.MeshPhongMaterial({ color: 0x2F2F2F });
                const coxa = new THREE.Mesh(coxaGeometry, legMaterial);
                legGroup.add(coxa);
                
                // Femur (thigh)
                const femurGeometry = new THREE.CylinderGeometry(0.004, 0.003, 0.04, 6);
                const femur = new THREE.Mesh(femurGeometry, legMaterial);
                femur.position.set(0, -0.02, 0);
                femur.rotation.z = angle;
                legGroup.add(femur);
                
                // Tibia (shin)
                const tibiaGeometry = new THREE.CylinderGeometry(0.003, 0.002, 0.035, 6);
                const tibia = new THREE.Mesh(tibiaGeometry, legMaterial);
                tibia.position.set(
                    Math.sin(angle) * 0.035,
                    -0.055,
                    0
                );
                tibia.rotation.z = angle + Math.PI/6;
                legGroup.add(tibia);
                
                // Position the leg group
                legGroup.position.set(side * 0.08, -0.06, position);
                return legGroup;
            }
            
            // Add all six legs
            drosophilaModel.add(createLeg(-1, 0.08, Math.PI/4));    // Left front
            drosophilaModel.add(createLeg(1, 0.08, -Math.PI/4));    // Right front
            drosophilaModel.add(createLeg(-1, 0, Math.PI/2));       // Left middle
            drosophilaModel.add(createLeg(1, 0, -Math.PI/2));       // Right middle
            drosophilaModel.add(createLeg(-1, -0.08, 3*Math.PI/4)); // Left back
            drosophilaModel.add(createLeg(1, -0.08, -3*Math.PI/4)); // Right back
            
            // ANTENNAE - more detailed with segments
            function createAntenna(side) {
                const antennaGroup = new THREE.Group();
                
                // Scape (base segment)
                const scapeGeometry = new THREE.CylinderGeometry(0.003, 0.002, 0.015, 6);
                const antennaMaterial = new THREE.MeshPhongMaterial({ color: 0x2F2F2F });
                const scape = new THREE.Mesh(scapeGeometry, antennaMaterial);
                scape.position.set(0, 0.01, 0);
                antennaGroup.add(scape);
                
                // Pedicel (second segment)
                const pedicelGeometry = new THREE.CylinderGeometry(0.002, 0.001, 0.01, 6);
                const pedicel = new THREE.Mesh(pedicelGeometry, antennaMaterial);
                pedicel.position.set(0, 0.022, 0);
                antennaGroup.add(pedicel);
                
                // Flagellum (third segment with arista)
                const flagellumGeometry = new THREE.SphereGeometry(0.004, 8, 6);
                const flagellum = new THREE.Mesh(flagellumGeometry, antennaMaterial);
                flagellum.position.set(0, 0.03, 0);
                antennaGroup.add(flagellum);
                
                // Arista (feathery extension)
                const aristaGeometry = new THREE.CylinderGeometry(0.0005, 0.0005, 0.025, 4);
                const arista = new THREE.Mesh(aristaGeometry, antennaMaterial);
                arista.position.set(side * 0.01, 0.04, 0);
                arista.rotation.z = side * Math.PI/6;
                antennaGroup.add(arista);
                
                antennaGroup.position.set(side * 0.025, 0.04, 0.24);
                antennaGroup.rotation.z = side * Math.PI/8;
                return antennaGroup;
            }
            
            drosophilaModel.add(createAntenna(-1)); // Left antenna
            drosophilaModel.add(createAntenna(1));  // Right antenna
            
            // PROBOSCIS (feeding tube)
            const proboscisGeometry = new THREE.CylinderGeometry(0.002, 0.001, 0.015, 6);
            const proboscisMaterial = new THREE.MeshPhongMaterial({ color: 0x4A3F35 });
            const proboscis = new THREE.Mesh(proboscisGeometry, proboscisMaterial);
            proboscis.position.set(0, -0.02, 0.24);
            proboscis.rotation.x = Math.PI/4;
            drosophilaModel.add(proboscis);
            
            // Scale the entire model to appropriate size
            drosophilaModel.scale.set(1.5, 1.5, 1.5);
            
            scene.add(drosophilaModel);
        }
        
        function createArrow(color, name) {
            const group = new THREE.Group();
            group.name = name;
            
            // Arrow shaft (cylinder pointing up along Y-axis by default)
            const shaftGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1, 8);
            const shaftMaterial = new THREE.MeshPhongMaterial({ color: color });
            const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
            group.add(shaft);
            
            // Arrow head (cone pointing up along Y-axis by default)
            const headGeometry = new THREE.ConeGeometry(0.08, 0.2, 8);
            const headMaterial = new THREE.MeshPhongMaterial({ color: color });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            group.add(head);
            
            return group;
        }
        
        function updateArrow(arrow, direction, scale = 1) {
            if (!arrow) return;
            
            const length = direction.length() * scale;
            const normalizedDirection = direction.clone().normalize();
            
            // Calculate the actual arrow length (shaft + head)
            const headHeight = 0.2;
            const shaftLength = Math.max(0.1, length - headHeight * 0.5);
            
            // Update shaft
            const shaft = arrow.children[0];
            shaft.scale.set(1, shaftLength, 1);
            shaft.position.set(0, shaftLength / 2, 0);
            
            // Update head position (place it at the end of the shaft)
            const head = arrow.children[1];
            head.position.set(0, shaftLength + headHeight / 2, 0);
            
            // Create a transformation matrix to orient the arrow
            const up = new THREE.Vector3(0, 1, 0);
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(up, normalizedDirection);
            
            // Apply the rotation to the entire arrow group
            arrow.setRotationFromQuaternion(quaternion);
        }
        
        function calculateTiltVector(alphaDeg, gammaDeg) {
            const alpha = alphaDeg * Math.PI / 180;
            const gamma = gammaDeg * Math.PI / 180;
            
            // Paper coordinate system: GX = sin(α)cos(γ), GY = sin(α)sin(γ), GZ = -cos(α)
            const x = Math.sin(alpha) * Math.cos(gamma);  // GX
            const y = Math.sin(alpha) * Math.sin(gamma);  // GY
            const z = -Math.cos(alpha);                   // GZ
            
            return new THREE.Vector3(x, y, z);
        }
        
        function calculateOrientationVector(alphaDeg, gammaDeg) {
            // Orientation vector represents the head/body "up" direction
            // This is the direction that was originally "up" in the head frame
            // After rotation by α and γ, the original [0,0,1] becomes:
            
            const alpha = alphaDeg * Math.PI / 180;
            const gamma = gammaDeg * Math.PI / 180;
            
            // Head "up" direction after rotations
            const x = -Math.sin(alpha) * Math.cos(gamma);  // X component
            const y = -Math.sin(alpha) * Math.sin(gamma);  // Y component  
            const z = Math.cos(alpha);                     // Z component
            
            return new THREE.Vector3(x, y, z);
        }
        
        
        function calculateYawOnlyAzimuth(alphaDeg, gammaDeg) {
            // YO: Yaw-Only azimuth - projects gravity vector onto horizontal plane and calculates azimuth
            // This ignores tilt and only considers rotation around the vertical axis
            const alpha = alphaDeg * Math.PI / 180;
            const gamma = gammaDeg * Math.PI / 180;
            
            // Project gravity vector components using correct coordinate system
            const gx = Math.sin(alpha) * Math.cos(gamma);   // GX
            const gy = Math.sin(alpha) * Math.sin(gamma);   // GY
            
            // Calculate azimuth in horizontal plane (atan2(gy, gx))
            let yoAzimuth = Math.atan2(gy, gx) * 180 / Math.PI;
            
            // Normalize to [0, 360] degrees
            while (yoAzimuth < 0) yoAzimuth += 360;
            while (yoAzimuth >= 360) yoAzimuth -= 360;
            
            return yoAzimuth;
        }
        
        function calculateEarthHorizontalAzimuth(alphaDeg, gammaDeg) {
            // EH: Earth-Horizontal azimuth - azimuth relative to earth's horizontal plane
            // This accounts for the device's tilt relative to earth's gravity
            const alpha = alphaDeg * Math.PI / 180;
            const gamma = gammaDeg * Math.PI / 180;
            
            // Calculate gravity vector components using correct coordinate system
            const gx = Math.sin(alpha) * Math.cos(gamma);   // GX
            const gy = Math.sin(alpha) * Math.sin(gamma);   // GY
            const gz = -Math.cos(alpha);                    // GZ
            
            // Project onto earth-horizontal plane (perpendicular to earth's gravity [0,0,-1])
            // Remove the vertical component and normalize the horizontal projection
            const horizontalMagnitude = Math.sqrt(gx * gx + gy * gy);
            
            if (horizontalMagnitude < 1e-6) {
                return 0; // Undefined when perfectly vertical
            }
            
            const hx = gx / horizontalMagnitude;
            const hy = gy / horizontalMagnitude;
            
            // Calculate azimuth in earth-horizontal frame
            let ehAzimuth = Math.atan2(hy, hx) * 180 / Math.PI;
            
            // Normalize to [0, 360] degrees
            while (ehAzimuth < 0) ehAzimuth += 360;
            while (ehAzimuth >= 360) ehAzimuth -= 360;
            
            return ehAzimuth;
        }
        
        function calculateTiltedAzimuth(alphaDeg, gammaDeg, ehazDeg) {
            // TA: Tilted azimuth - azimuth in the tilted reference frame
            // This uses the original True Anomaly calculation
            const alpha = alphaDeg * Math.PI / 180;
            const gamma = gammaDeg * Math.PI / 180;
            const ehaz = ehazDeg * Math.PI / 180;
            
            // TA = EHAz - γ - atan2(-sin(γ), cos(α) * cos(γ))
            const ta = ehaz - gamma - Math.atan2(-Math.sin(gamma), Math.cos(alpha) * Math.cos(gamma));
            
            // Convert back to degrees and normalize to [0, 360]
            let taDeg = ta * 180 / Math.PI;
            while (taDeg < 0) taDeg += 360;
            while (taDeg >= 360) taDeg -= 360;
            
            return taDeg;
        }
        
        function updateCalculations() {
            const paperVector = calculateTiltVector(currentAlpha, currentGamma);
            
            // Update vectors
            updateOrientationVector();
            updateGVector();
            
            // Calculate all three azimuth values
            const yo = calculateYawOnlyAzimuth(currentAlpha, currentGamma);
            const eh = calculateEarthHorizontalAzimuth(currentAlpha, currentGamma);
            const ta = calculateTiltedAzimuth(currentAlpha, currentGamma, EHAz);
            
            // Update drosophila model orientation
            updateDrosophilaOrientation();
            
            // Update display with paper coordinates
            document.getElementById('gx').textContent = paperVector.x.toFixed(3);
            document.getElementById('gy').textContent = paperVector.y.toFixed(3);
            document.getElementById('gz').textContent = paperVector.z.toFixed(3);
            document.getElementById('gnorm').textContent = paperVector.length().toFixed(3);
            
            // Update azimuth displays
            document.getElementById('yo').textContent = yo.toFixed(2);
            document.getElementById('eh').textContent = eh.toFixed(2);
            document.getElementById('ta').textContent = ta.toFixed(2);
            
            // Verify inverse transformation (for debugging/validation)
            verifyInverseTransformation(paperVector.x, paperVector.y, paperVector.z);
            
            // Update sphere position marker
            updateSpherePosition();
        }
        
        function updateOrientationVector() {
            if (!orientationVector) return;
            
            const paperOrientationVector = calculateOrientationVector(currentAlpha, currentGamma);
            
            // Transform paper coordinates to Three.js coordinates for display
            // Paper: X=right, Y=nose, Z=up  →  Three.js: X=right, Y=up, Z=forward
            const displayOrientationVector = new THREE.Vector3(
                paperOrientationVector.x,  // Right ear → X (same)
                paperOrientationVector.z,  // Up → Y (Three.js up)
                paperOrientationVector.y   // Nose → Z (Three.js forward)
            );
            
            updateArrow(orientationVector, displayOrientationVector, vectorScale);
        }
        
        function updateGVector() {
            if (!gVector) return;
            
            const paperGVector = calculateTiltVector(currentAlpha, currentGamma);
            
            // Transform paper coordinates to Three.js coordinates for display
            // Paper: X=right, Y=nose, Z=up  →  Three.js: X=right, Y=up, Z=forward
            const displayGVector = new THREE.Vector3(
                paperGVector.x,  // Right ear → X (same)
                paperGVector.z,  // Up → Y (Three.js up)
                paperGVector.y   // Nose → Z (Three.js forward)
            );
            
            updateArrow(gVector, displayGVector, vectorScale);
        }
        
        function verifyInverseTransformation(gx, gy, gz) {
            // Inverse transformation: GX, GY, GZ → α, γ
            const calculatedAlpha = Math.acos(-gz) * 180 / Math.PI;
            const calculatedGamma = Math.atan2(gy, gx) * 180 / Math.PI;
            
            // Optional: log to console for verification
            // console.log(`Inverse check: α=${calculatedAlpha.toFixed(2)}°, γ=${calculatedGamma.toFixed(2)}°`);
        }
        
        function updateDrosophilaOrientation() {
            if (!drosophilaModel) return;
            
            // Convert angles to radians
            const alpha = currentAlpha * Math.PI / 180;
            const gamma = currentGamma * Math.PI / 180;
            
            // Reset rotation
            drosophilaModel.rotation.set(0, 0, 0);
            
            // Paper coordinate system: X=right ear, Y=nose, Z=up
            // Paper conventions: 
            // - γ=0°: Nose-Down (ND) - positioned for pitch down
            // - γ=180°: Nose-Up (NU) - positioned for pitch up  
            // - γ=90°: Left-Ear-Down (LED) - positioned for left roll
            // - γ=-90°: Right-Ear-Down (RED) - positioned for right roll
            // Note: γ sets the orientation/position, α executes the movement
            
            // The drosophila model was built with nose pointing in +Z direction (Three.js forward)
            // For proper roll representation, we need to think about the rotation axes:
            
            // In aircraft/biology terms:
            // - Pitch: rotation around X-axis (left ear to right ear axis)
            // - Roll: rotation around Y-axis (nose-to-tail axis) 
            // - Yaw: rotation around Z-axis (vertical axis)
            
            // Apply gamma rotation: this controls both pitch and roll depending on angle
            // For γ=0°/180° (ND/NU): should be pitch (rotation around X-axis)
            // For γ=±90° (LED/RED): should be roll (rotation around Z-axis of model)
            
            // Since γ mixes pitch and roll, we apply it as rotation around Z-axis (nose-tail axis)
            drosophilaModel.rotateZ(gamma);
            
            // Then apply alpha rotation around X-axis for overall tilt
            drosophilaModel.rotateX(alpha);
        }
        
        function updateCustomVector() {
            const vector = new THREE.Vector3(
                currentCustomVector.x,
                currentCustomVector.y,
                currentCustomVector.z
            ).normalize();
            
            updateArrow(customVector, vector, vectorScale);
            
            // Update display
            const originalLength = Math.sqrt(
                currentCustomVector.x * currentCustomVector.x +
                currentCustomVector.y * currentCustomVector.y +
                currentCustomVector.z * currentCustomVector.z
            );
            
            document.getElementById('customGx').textContent = currentCustomVector.x.toFixed(3);
            document.getElementById('customGy').textContent = currentCustomVector.y.toFixed(3);
            document.getElementById('customGz').textContent = currentCustomVector.z.toFixed(3);
            document.getElementById('customGnorm').textContent = originalLength.toFixed(3);
        }
        
        function setupEventListeners() {
            // Tilt controls
            const alphaRange = document.getElementById('alphaRange');
            const alphaNumber = document.getElementById('alphaNumber');
            const gammaRange = document.getElementById('gammaRange');
            const gammaNumber = document.getElementById('gammaNumber');
            
            function syncAlpha() {
                currentAlpha = parseFloat(alphaRange.value);
                alphaNumber.value = currentAlpha;
                updateCalculations();
            }
            
            function syncGamma() {
                currentGamma = parseFloat(gammaRange.value);
                gammaNumber.value = currentGamma;
                updateCalculations();
            }
            
            
            alphaRange.addEventListener('input', syncAlpha);
            alphaNumber.addEventListener('input', () => {
                alphaRange.value = alphaNumber.value;
                syncAlpha();
            });
            
            gammaRange.addEventListener('input', syncGamma);
            gammaNumber.addEventListener('input', () => {
                gammaRange.value = gammaNumber.value;
                syncGamma();
            });
            
            
            // Custom vector controls
            document.getElementById('customX').addEventListener('input', updateCustomVectorFromInputs);
            document.getElementById('customY').addEventListener('input', updateCustomVectorFromInputs);
            document.getElementById('customZ').addEventListener('input', updateCustomVectorFromInputs);
            
            // Scale controls
            const scaleRange = document.getElementById('scaleRange');
            const scaleNumber = document.getElementById('scaleNumber');
            
            function updateScale() {
                vectorScale = parseFloat(scaleRange.value);
                scaleNumber.value = vectorScale;
                updateCalculations();
                updateCustomVector();
            }
            
            scaleRange.addEventListener('input', updateScale);
            scaleNumber.addEventListener('input', () => {
                scaleRange.value = scaleNumber.value;
                updateScale();
            });
            
            // Visibility controls
            document.getElementById('showAxes').addEventListener('change', (e) => {
                Object.values(coordinateAxes).forEach(axis => {
                    if (axis) axis.visible = e.target.checked;
                });
            });
            
            document.getElementById('showGrid').addEventListener('change', (e) => {
                if (gridHelper) gridHelper.visible = e.target.checked;
            });
            
            document.getElementById('showCustomVector').addEventListener('change', (e) => {
                if (customVector) customVector.visible = e.target.checked;
            });
            
            document.getElementById('showOrientationVector').addEventListener('change', (e) => {
                if (orientationVector) orientationVector.visible = e.target.checked;
            });
            
            document.getElementById('showGVector').addEventListener('change', (e) => {
                if (gVector) gVector.visible = e.target.checked;
            });
            
            document.getElementById('showDrosophila').addEventListener('change', (e) => {
                if (drosophilaModel) drosophilaModel.visible = e.target.checked;
            });
            
            document.getElementById('showSphere').addEventListener('change', (e) => {
                if (referenceSphere) referenceSphere.visible = e.target.checked;
                if (sphereGridLines) sphereGridLines.visible = e.target.checked;
                if (currentPositionMarker) currentPositionMarker.visible = e.target.checked;
            });
        }
        
        function updateCustomVectorFromInputs() {
            currentCustomVector.x = parseFloat(document.getElementById('customX').value) || 0;
            currentCustomVector.y = parseFloat(document.getElementById('customY').value) || 0;
            currentCustomVector.z = parseFloat(document.getElementById('customZ').value) || 0;
            updateCustomVector();
        }
        
        function setPreset(preset) {
            switch (preset) {
                case 'upright':
                    currentAlpha = 0; currentGamma = 0; break;     // UP: α=0°, γ=0°
                case 'upsidedown':
                    currentAlpha = 180; currentGamma = 0; break;   // UD: α=180°, γ=0°
                case 'nosedown':
                    currentAlpha = 90; currentGamma = 0; break;    // ND: α=90°, γ=0° (pitch forward)
                case 'noseup':
                    currentAlpha = 90; currentGamma = 180; break;  // NU: α=90°, γ=180° (pitch backward)
                case 'lefteardown':
                    currentAlpha = 90; currentGamma = 90; break;   // LED: α=90°, γ=90° (roll left - left ear down)
                case 'righteardown':
                    currentAlpha = 90; currentGamma = -90; break;  // RED: α=90°, γ=-90° (roll right - right ear down)
                case 'diagonal1':
                    currentAlpha = 45; currentGamma = 45; break;   // Diagonal: ND+LED
                case 'diagonal2':
                    currentAlpha = 45; currentGamma = -135; break; // Diagonal: NU+RED
                case 'sleeping':
                    currentAlpha = 90; currentGamma = 90; break;   // Same as LED
                case 'climbing':
                    currentAlpha = 45; currentGamma = 0; break;    // Moderate forward tilt
                case 'hanging':
                    currentAlpha = 135; currentGamma = 0; break;   // Inverted climbing
                case 'custom':
                    // Use current values for inverse calculation demo
                    break;
            }
            
            document.getElementById('alphaRange').value = currentAlpha;
            document.getElementById('alphaNumber').value = currentAlpha;
            document.getElementById('gammaRange').value = currentGamma;
            document.getElementById('gammaNumber').value = currentGamma;
            
            updateCalculations();
        }
        
        function applyCustomVector() {
            updateCustomVectorFromInputs();
        }
        
        function toggleMathSection() {
            const mathSection = document.getElementById('mathSection');
            const mathToggle = document.getElementById('mathToggle');
            
            if (mathSection.style.display === 'none') {
                mathSection.style.display = 'block';
                mathToggle.textContent = '▲';
            } else {
                mathSection.style.display = 'none';
                mathToggle.textContent = '▼';
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const container = document.querySelector('.canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
